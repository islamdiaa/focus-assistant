/**
 * Server-side Markdown file storage
 *
 * Reads/writes app state to a local .md file on the server filesystem.
 * The file path defaults to ./data/focus-assist-data.md (Docker volume mount point).
 *
 * V1.2: Added subtasks (JSON in column), templates section, preferences section
 */
import fs from "fs/promises";
import path from "path";
import type {
  Task,
  Pomodoro,
  PomodoroLink,
  AppState,
  TaskTemplate,
  AppPreferences,
  ReadingItem,
  Reminder,
} from "../shared/appTypes";
import { syncToObsidian } from "./obsidianSync";
import { DEFAULT_SETTINGS, DEFAULT_PREFERENCES } from "../shared/appTypes";

const DATA_DIR = process.env.DATA_DIR || path.join(process.cwd(), "data");
const DATA_FILE = path.join(DATA_DIR, "focus-assist-data.md");

async function ensureDataDir() {
  await fs.mkdir(DATA_DIR, { recursive: true });
}

// ---- Markdown serialization ----

function escapeField(val: string): string {
  return val.replace(/\|/g, "\\|").replace(/\n/g, "\\n");
}

function unescapeField(val: string): string {
  return val.replace(/\\n/g, "\n").replace(/\\\|/g, "|");
}

// C6 fix: NaN-safe parseInt that doesn't treat 0 as falsy
function safeParseInt(val: string, fallback: number): number {
  const n = parseInt(val, 10);
  return isNaN(n) ? fallback : n;
}

export function stateToMarkdown(state: AppState): string {
  const lines: string[] = [];

  lines.push("# Focus Assist Data");
  lines.push("");
  lines.push("> Auto-generated by Focus Assist. Edit with care.");
  lines.push("");

  // Settings
  lines.push("## Settings");
  lines.push("");
  lines.push(`- **Focus Duration:** ${state.settings.focusDuration} min`);
  lines.push(`- **Short Break:** ${state.settings.shortBreak} min`);
  lines.push(`- **Long Break:** ${state.settings.longBreak} min`);
  lines.push(
    `- **Sessions Before Long Break:** ${state.settings.sessionsBeforeLongBreak}`
  );
  lines.push(`- **Current Streak:** ${state.currentStreak} days`);
  lines.push("");

  // Preferences
  if (state.preferences) {
    lines.push("## Preferences");
    lines.push("");
    lines.push(
      `- **Notification Sound:** ${state.preferences.notificationSound || "gentle-chime"}`
    );
    lines.push(
      `- **Obsidian Vault Path:** ${state.preferences.obsidianVaultPath || ""}`
    );
    lines.push(
      `- **Obsidian Auto Sync:** ${state.preferences.obsidianAutoSync ? "true" : "false"}`
    );
    lines.push(
      `- **Active Context:** ${state.preferences.activeContext || "all"}`
    );
    lines.push(
      `- **Auto Complete Parent:** ${state.preferences.autoCompleteParent ? "true" : "false"}`
    );
    lines.push(
      `- **Available Hours Per Day:** ${state.preferences.availableHoursPerDay ?? 8}`
    );
    lines.push("");
  }

  // Tasks
  lines.push("## Tasks");
  lines.push("");
  if (state.tasks.length === 0) {
    lines.push("_No tasks yet._");
  } else {
    lines.push(
      "| ID | Title | Description | Priority | Status | Due Date | Category | Energy | Quadrant | Created | Completed | Recurrence | RecurrenceParentId | RecurrenceNextDate | Subtasks | RecurrenceDayOfMonth | RecurrenceStartMonth | PinnedToday | StatusChangedAt | IsFocusGoal | EstimatedMinutes |"
    );
    lines.push(
      "|----|-------|-------------|----------|--------|----------|----------|--------|----------|---------|-----------|------------|--------------------|--------------------|----------|---------------------|----------------------|-------------|-----------------|-------------|------------------|"
    );
    for (const t of state.tasks) {
      const subtasksJson =
        t.subtasks && t.subtasks.length > 0
          ? escapeField(JSON.stringify(t.subtasks))
          : "";
      lines.push(
        `| ${t.id} | ${escapeField(t.title)} | ${escapeField(t.description || "")} | ${t.priority} | ${t.status} | ${t.dueDate || ""} | ${t.category || ""} | ${t.energy || ""} | ${t.quadrant} | ${t.createdAt} | ${t.completedAt || ""} | ${t.recurrence || ""} | ${t.recurrenceParentId || ""} | ${t.recurrenceNextDate || ""} | ${subtasksJson} | ${t.recurrenceDayOfMonth ?? ""} | ${t.recurrenceStartMonth ?? ""} | ${t.pinnedToday || ""} | ${t.statusChangedAt || ""} | ${t.isFocusGoal ? "true" : ""} | ${t.estimatedMinutes ?? ""} |`
      );
    }
  }
  lines.push("");

  // Pomodoros
  lines.push("## Pomodoros");
  lines.push("");
  if (state.pomodoros.length === 0) {
    lines.push("_No pomodoros yet._");
  } else {
    lines.push(
      "| ID | Title | Duration | Elapsed | Status | Created | Completed | StartedAt | AccumulatedSeconds | LinkedTaskId | LinkedTasks |"
    );
    lines.push(
      "|----|-------|----------|---------|--------|---------|-----------|-----------|---------------------|--------------|-------------|"
    );
    for (const p of state.pomodoros) {
      const linkedTasksJson =
        p.linkedTasks && p.linkedTasks.length > 0
          ? escapeField(JSON.stringify(p.linkedTasks))
          : "";
      lines.push(
        `| ${p.id} | ${escapeField(p.title)} | ${p.duration} | ${p.elapsed} | ${p.status} | ${p.createdAt} | ${p.completedAt || ""} | ${p.startedAt || ""} | ${p.accumulatedSeconds ?? ""} | ${p.linkedTaskId || ""} | ${linkedTasksJson} |`
      );
    }
  }
  lines.push("");

  // Daily Stats
  lines.push("## Daily Stats");
  lines.push("");
  if (state.dailyStats.length === 0) {
    lines.push("_No stats yet._");
  } else {
    lines.push(
      "| Date | Tasks Completed | Focus Minutes | Pomodoros Completed |"
    );
    lines.push(
      "|------|-----------------|---------------|---------------------|"
    );
    for (const s of state.dailyStats) {
      lines.push(
        `| ${s.date} | ${s.tasksCompleted} | ${s.focusMinutes} | ${s.pomodorosCompleted} |`
      );
    }
  }
  lines.push("");

  // Reading List
  if (state.readingList && state.readingList.length > 0) {
    lines.push("## Reading List");
    lines.push("");
    lines.push(
      "| ID | URL | Title | Description | Tags | Status | Notes | ImageUrl | Domain | Created | ReadAt |"
    );
    lines.push(
      "|----|-----|-------|-------------|------|--------|-------|----------|--------|---------|--------|"
    );
    for (const r of state.readingList) {
      lines.push(
        `| ${r.id} | ${escapeField(r.url)} | ${escapeField(r.title)} | ${escapeField(r.description || "")} | ${escapeField(r.tags.join(","))} | ${r.status} | ${escapeField(r.notes || "")} | ${r.imageUrl || ""} | ${r.domain || ""} | ${r.createdAt} | ${r.readAt || ""} |`
      );
    }
    lines.push("");
  }

  // Reminders
  if (state.reminders && state.reminders.length > 0) {
    lines.push("## Reminders");
    lines.push("");
    lines.push(
      "| ID | Title | Description | Date | Time | Recurrence | Category | Acknowledged | AcknowledgedAt | Created |"
    );
    lines.push(
      "|----|-------|-------------|------|------|------------|----------|--------------|----------------|---------|"
    );
    for (const r of state.reminders) {
      lines.push(
        `| ${r.id} | ${escapeField(r.title)} | ${escapeField(r.description || "")} | ${r.date} | ${r.time || ""} | ${r.recurrence} | ${r.category} | ${r.acknowledged === true ? "true" : r.acknowledged === false ? "false" : ""} | ${r.acknowledgedAt || ""} | ${r.createdAt} |`
      );
    }
    lines.push("");
  }

  // Scratch Pad
  if (state.scratchPad && state.scratchPad.length > 0) {
    lines.push("## Scratch Pad");
    lines.push("");
    lines.push("| ID | Text | Created |");
    lines.push("|----|------|---------|");
    for (const n of state.scratchPad) {
      lines.push(`| ${n.id} | ${escapeField(n.text)} | ${n.createdAt} |`);
    }
    lines.push("");
  }

  // Templates
  if (state.templates && state.templates.length > 0) {
    lines.push("## Templates");
    lines.push("");
    lines.push("| ID | Name | Description | Tasks | Created |");
    lines.push("|----|------|-------------|-------|---------|");
    for (const tmpl of state.templates) {
      const tasksJson = escapeField(JSON.stringify(tmpl.tasks));
      lines.push(
        `| ${tmpl.id} | ${escapeField(tmpl.name)} | ${escapeField(tmpl.description || "")} | ${tasksJson} | ${tmpl.createdAt} |`
      );
    }
    lines.push("");
  }

  return lines.join("\n");
}

function parseMarkdownTable(lines: string[]): string[][] {
  const rows: string[][] = [];
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed.startsWith("|")) continue;
    if (/^\|[\s\-:|]+\|$/.test(trimmed)) continue;
    // Split on unescaped pipes only (not preceded by backslash)
    const inner = trimmed.slice(1, -1); // remove leading/trailing |
    const cells: string[] = [];
    let current = "";
    for (let i = 0; i < inner.length; i++) {
      if (inner[i] === "\\" && i + 1 < inner.length && inner[i + 1] === "|") {
        current += "\\|";
        i++; // skip the pipe
      } else if (inner[i] === "|") {
        cells.push(unescapeField(current.trim()));
        current = "";
      } else {
        current += inner[i];
      }
    }
    cells.push(unescapeField(current.trim()));
    rows.push(cells);
  }
  return rows;
}

export function markdownToState(md: string): AppState {
  const state: AppState = {
    tasks: [],
    pomodoros: [],
    settings: { ...DEFAULT_SETTINGS },
    dailyStats: [],
    currentStreak: 0,
    templates: [],
    preferences: { ...DEFAULT_PREFERENCES },
    readingList: [],
    reminders: [],
    scratchPad: [],
  };

  const sections = md.split(/^## /m);

  for (const section of sections) {
    const sectionLines = section.split("\n");
    const title = sectionLines[0]?.trim().toLowerCase();

    if (title === "settings") {
      for (const line of sectionLines) {
        const match = line.match(/\*\*(.+?):\*\*\s*(.+)/);
        if (!match) continue;
        const key = match[1].trim().toLowerCase();
        const val = match[2].trim();
        if (key === "focus duration")
          state.settings.focusDuration = safeParseInt(
            val,
            DEFAULT_SETTINGS.focusDuration
          );
        if (key === "short break")
          state.settings.shortBreak = safeParseInt(
            val,
            DEFAULT_SETTINGS.shortBreak
          );
        if (key === "long break")
          state.settings.longBreak = safeParseInt(
            val,
            DEFAULT_SETTINGS.longBreak
          );
        if (key === "sessions before long break")
          state.settings.sessionsBeforeLongBreak = safeParseInt(
            val,
            DEFAULT_SETTINGS.sessionsBeforeLongBreak
          );
        if (key === "current streak")
          state.currentStreak = safeParseInt(val, 0);
      }
    }

    if (title === "preferences") {
      for (const line of sectionLines) {
        const match = line.match(/\*\*(.+?):\*\*\s*(.*)/);
        if (!match) continue;
        const key = match[1].trim().toLowerCase();
        const val = match[2].trim();
        if (key === "notification sound")
          state.preferences!.notificationSound = (val as any) || "gentle-chime";
        if (key === "obsidian vault path")
          state.preferences!.obsidianVaultPath = val || "";
        if (key === "obsidian auto sync")
          state.preferences!.obsidianAutoSync = val === "true";
        if (key === "active context")
          state.preferences!.activeContext = (
            ["all", "work", "personal"].includes(val) ? val : "all"
          ) as any;
        if (key === "auto complete parent")
          state.preferences!.autoCompleteParent = val === "true";
        if (key === "available hours per day")
          state.preferences!.availableHoursPerDay = val ? parseFloat(val) : 8;
      }
    }

    if (title === "tasks") {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        // Column-count resilience: safely access columns that may not exist in older formats
        // Old format had 15 columns (indices 0-14), V1.8.1 added 2 more (15-16), V1.8.3 added 1 more (17)
        const col = (idx: number) => (idx < r.length ? r[idx] : "") || "";
        let subtasks = undefined;
        const subtasksRaw = col(14);
        if (subtasksRaw) {
          try {
            subtasks = JSON.parse(subtasksRaw);
          } catch {
            /* ignore parse errors */
          }
        }
        state.tasks.push({
          id: r[0],
          title: r[1] || "",
          description: r[2] || undefined,
          priority: (r[3] as Task["priority"]) || "medium",
          status: (r[4] as Task["status"]) || "active",
          dueDate: col(5) || undefined,
          category: (col(6) as Task["category"]) || undefined,
          energy: (col(7) as Task["energy"]) || undefined,
          quadrant: (col(8) as Task["quadrant"]) || "unassigned",
          createdAt: col(9) || new Date().toISOString(),
          completedAt: col(10) || undefined,
          recurrence: (col(11) as Task["recurrence"]) || undefined,
          recurrenceParentId: col(12) || undefined,
          recurrenceNextDate: col(13) || undefined,
          subtasks,
          recurrenceDayOfMonth: col(15) ? parseInt(col(15)) : undefined,
          recurrenceStartMonth: col(16) ? parseInt(col(16)) : undefined,
          pinnedToday: col(17) || undefined,
          statusChangedAt: col(18) || undefined,
          isFocusGoal: col(19) === "true" ? true : undefined,
          estimatedMinutes: col(20) ? parseInt(col(20)) : undefined,
        });
      }
    }

    if (title === "pomodoros") {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        let linkedTasks: PomodoroLink[] | undefined = undefined;
        if (r[10]) {
          try {
            linkedTasks = JSON.parse(r[10]);
          } catch {
            /* ignore */
          }
        }
        state.pomodoros.push({
          id: r[0],
          title: r[1] || "",
          duration: safeParseInt(r[2], 25),
          elapsed: safeParseInt(r[3], 0),
          status: (r[4] as Pomodoro["status"]) || "idle",
          createdAt: r[5] || new Date().toISOString(),
          completedAt: r[6] || undefined,
          startedAt: r[7] || undefined,
          accumulatedSeconds: r[8] ? safeParseInt(r[8], 0) : undefined,
          linkedTaskId: r[9] || undefined,
          linkedTasks,
        });
      }
    }

    if (title === "daily stats") {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        state.dailyStats.push({
          date: r[0],
          tasksCompleted: safeParseInt(r[1], 0),
          focusMinutes: safeParseInt(r[2], 0),
          pomodorosCompleted: safeParseInt(r[3], 0),
        });
      }
    }

    if (title === "reading list") {
      state.readingList = [];
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        state.readingList.push({
          id: r[0],
          url: r[1] || "",
          title: r[2] || "",
          description: r[3] || undefined,
          tags: r[4]
            ? r[4]
                .split(",")
                .map(t => t.trim())
                .filter(Boolean)
            : [],
          status: (r[5] as ReadingItem["status"]) || "unread",
          notes: r[6] || undefined,
          imageUrl: r[7] || undefined,
          domain: r[8] || undefined,
          createdAt: r[9] || new Date().toISOString(),
          readAt: r[10] || undefined,
        });
      }
    }

    if (title === "reminders") {
      state.reminders = [];
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        state.reminders.push({
          id: r[0],
          title: r[1] || "",
          description: r[2] || undefined,
          date: r[3] || "",
          time: r[4] || undefined,
          recurrence: (r[5] as Reminder["recurrence"]) || "none",
          category: (r[6] as Reminder["category"]) || "other",
          acknowledged:
            r[7] === "true" ? true : r[7] === "false" ? false : undefined,
          acknowledgedAt: r[8] || undefined,
          createdAt: r[9] || new Date().toISOString(),
        });
      }
    }

    if (title === "scratch pad") {
      state.scratchPad = [];
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        state.scratchPad.push({
          id: r[0],
          text: r[1] || "",
          createdAt: r[2] || new Date().toISOString(),
        });
      }
    }

    if (title === "templates") {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        let tasks: TaskTemplate["tasks"] = [];
        if (r[3]) {
          try {
            tasks = JSON.parse(r[3]);
          } catch {
            /* ignore */
          }
        }
        state.templates!.push({
          id: r[0],
          name: r[1] || "",
          description: r[2] || undefined,
          tasks,
          createdAt: r[4] || new Date().toISOString(),
        });
      }
    }
  }

  return state;
}

// ---- Public API ----

export async function loadFromMdFile(): Promise<AppState | null> {
  try {
    await ensureDataDir();
    const text = await fs.readFile(DATA_FILE, "utf-8");
    if (!text.trim()) return null;
    return markdownToState(text);
  } catch (e: any) {
    if (e.code === "ENOENT") return null;
    // H5 fix: throw on corrupt/unreadable file instead of silently returning null
    // This prevents the caller from treating corrupt data as "no data" and saving empty state
    console.error("Failed to read MD file (data may be corrupt):", e);
    throw new Error(`Failed to load data file: ${e.message || e}`);
  }
}

const MAX_BACKUPS = 5;

async function rotateBackups(): Promise<void> {
  try {
    // Check if main file exists
    await fs.access(DATA_FILE);
  } catch {
    return; // No file to backup
  }

  try {
    // Shift existing backups: .bak.5 → delete, .bak.4 → .bak.5, etc.
    for (let i = MAX_BACKUPS; i >= 1; i--) {
      const src = i === 1 ? DATA_FILE : `${DATA_FILE}.bak.${i - 1}`;
      const dst = `${DATA_FILE}.bak.${i}`;
      try {
        await fs.access(src);
        await fs.copyFile(src, dst);
      } catch {
        // Source doesn't exist, skip
      }
    }
  } catch (e) {
    console.warn("Backup rotation failed:", e);
  }
}

const DAILY_BACKUP_DIR = path.join(DATA_DIR, "daily_backup");

/**
 * Create a daily snapshot if one doesn't exist yet for today.
 * Snapshots are stored as /data/daily_backup/YYYY-MM-DD.md and kept indefinitely.
 */
export async function createDailySnapshot(): Promise<void> {
  try {
    await fs.mkdir(DAILY_BACKUP_DIR, { recursive: true });
    const today = new Date().toISOString().split("T")[0]; // YYYY-MM-DD
    const snapshotPath = path.join(DAILY_BACKUP_DIR, `${today}.md`);
    try {
      await fs.access(snapshotPath);
      // Snapshot already exists for today, skip
      return;
    } catch {
      // Doesn't exist yet — create it
    }
    try {
      await fs.access(DATA_FILE);
      await fs.copyFile(DATA_FILE, snapshotPath);
    } catch {
      // No data file to snapshot yet
    }
  } catch (e) {
    console.warn("Daily snapshot failed:", e);
  }
}

// C4 fix: simple promise-based write mutex to serialize concurrent saves
let writeLock: Promise<void> = Promise.resolve();

export async function saveToMdFile(state: AppState): Promise<boolean> {
  // Queue this write behind any in-progress write
  return new Promise<boolean>(resolve => {
    writeLock = writeLock.then(async () => {
      try {
        await ensureDataDir();
        await rotateBackups();
        await createDailySnapshot();
        // C4 fix: atomic write — write to temp file then rename (atomic on POSIX)
        const tmpFile = DATA_FILE + ".tmp";
        await fs.writeFile(tmpFile, stateToMarkdown(state), "utf-8");
        await fs.rename(tmpFile, DATA_FILE);
        // Obsidian vault sync (fire-and-forget, don't block save)
        syncToObsidian(state).catch(e =>
          console.warn("[ObsidianSync] Error:", e)
        );
        resolve(true);
      } catch (e) {
        console.warn("Failed to write MD file:", e);
        // Clean up temp file if it exists
        try {
          await fs.unlink(DATA_FILE + ".tmp");
        } catch {
          /* ignore */
        }
        resolve(false);
      }
    });
  });
}

/** Get the file's last modified timestamp for polling */
export async function getMdFileTimestamp(): Promise<number> {
  try {
    const stat = await fs.stat(DATA_FILE);
    return stat.mtimeMs;
  } catch {
    return 0;
  }
}

/** Data integrity check — verify and fix MD file structure */
export async function checkDataIntegrity(): Promise<{
  ok: boolean;
  issues: string[];
  fixed: string[];
}> {
  const issues: string[] = [];
  const fixed: string[] = [];

  try {
    const text = await fs.readFile(DATA_FILE, "utf-8");
    if (!text.trim()) {
      return {
        ok: true,
        issues: ["File is empty — no data to check"],
        fixed: [],
      };
    }

    const state = markdownToState(text);

    // Check for duplicate task IDs
    const taskIds = new Set<string>();
    for (const t of state.tasks) {
      if (taskIds.has(t.id)) {
        issues.push(`Duplicate task ID: ${t.id}`);
      }
      taskIds.add(t.id);
    }

    // Check for duplicate pomodoro IDs
    const pomIds = new Set<string>();
    for (const p of state.pomodoros) {
      if (pomIds.has(p.id)) {
        issues.push(`Duplicate pomodoro ID: ${p.id}`);
      }
      pomIds.add(p.id);
    }

    // Check for invalid task statuses
    for (const t of state.tasks) {
      if (!["active", "done", "monitored"].includes(t.status)) {
        issues.push(`Task "${t.title}" has invalid status: ${t.status}`);
        t.status = "active";
        fixed.push(`Fixed task "${t.title}" status to "active"`);
      }
      if (!["low", "medium", "high", "urgent"].includes(t.priority)) {
        issues.push(`Task "${t.title}" has invalid priority: ${t.priority}`);
        t.priority = "medium";
        fixed.push(`Fixed task "${t.title}" priority to "medium"`);
      }
    }

    // Check for invalid pomodoro statuses
    for (const p of state.pomodoros) {
      if (!["idle", "running", "paused", "completed"].includes(p.status)) {
        issues.push(`Pomodoro "${p.title}" has invalid status: ${p.status}`);
        p.status = "idle";
        fixed.push(`Fixed pomodoro "${p.title}" status to "idle"`);
      }
    }

    // Check daily stats for duplicate dates
    const statDates = new Set<string>();
    const dedupedStats = [];
    for (const s of state.dailyStats) {
      if (statDates.has(s.date)) {
        issues.push(`Duplicate daily stats for date: ${s.date}`);
        fixed.push(`Removed duplicate stats for ${s.date}`);
      } else {
        statDates.add(s.date);
        dedupedStats.push(s);
      }
    }
    state.dailyStats = dedupedStats;

    // Check subtask integrity
    for (const t of state.tasks) {
      if (t.subtasks) {
        const subtaskIds = new Set<string>();
        for (const s of t.subtasks) {
          if (!s.id || !s.title) {
            issues.push(`Task "${t.title}" has malformed subtask`);
          }
          if (s.id && subtaskIds.has(s.id)) {
            issues.push(`Task "${t.title}" has duplicate subtask ID: ${s.id}`);
          }
          if (s.id) subtaskIds.add(s.id);
        }
      }
    }

    // If fixes were applied, re-save
    if (fixed.length > 0) {
      await saveToMdFile(state);
    }

    return {
      ok: issues.length === 0,
      issues: issues.length === 0 ? ["All data looks good!"] : issues,
      fixed,
    };
  } catch (e: any) {
    return {
      ok: false,
      issues: [`Failed to read data file: ${e.message}`],
      fixed: [],
    };
  }
}
