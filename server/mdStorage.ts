/**
 * Server-side Markdown file storage
 * 
 * Reads/writes app state to a local .md file on the server filesystem.
 * The file path defaults to ./data/focus-assist-data.md (Docker volume mount point).
 * 
 * V1.2: Added subtasks (JSON in column), templates section, preferences section
 */
import fs from 'fs/promises';
import path from 'path';
import type { Task, Pomodoro, AppState, TaskTemplate, AppPreferences } from '../shared/appTypes';
import { DEFAULT_SETTINGS, DEFAULT_PREFERENCES } from '../shared/appTypes';

const DATA_DIR = process.env.DATA_DIR || path.join(process.cwd(), 'data');
const DATA_FILE = path.join(DATA_DIR, 'focus-assist-data.md');

async function ensureDataDir() {
  await fs.mkdir(DATA_DIR, { recursive: true });
}

// ---- Markdown serialization ----

function escapeField(val: string): string {
  return val.replace(/\|/g, '\\|').replace(/\n/g, '\\n');
}

function unescapeField(val: string): string {
  return val.replace(/\\n/g, '\n').replace(/\\\|/g, '|');
}

export function stateToMarkdown(state: AppState): string {
  const lines: string[] = [];

  lines.push('# Focus Assist Data');
  lines.push('');
  lines.push('> Auto-generated by Focus Assist. Edit with care.');
  lines.push('');

  // Settings
  lines.push('## Settings');
  lines.push('');
  lines.push(`- **Focus Duration:** ${state.settings.focusDuration} min`);
  lines.push(`- **Short Break:** ${state.settings.shortBreak} min`);
  lines.push(`- **Long Break:** ${state.settings.longBreak} min`);
  lines.push(`- **Sessions Before Long Break:** ${state.settings.sessionsBeforeLongBreak}`);
  lines.push(`- **Current Streak:** ${state.currentStreak} days`);
  lines.push('');

  // Preferences
  if (state.preferences) {
    lines.push('## Preferences');
    lines.push('');
    lines.push(`- **Notification Sound:** ${state.preferences.notificationSound || 'gentle-chime'}`);
    lines.push(`- **Obsidian Vault Path:** ${state.preferences.obsidianVaultPath || ''}`);
    lines.push(`- **Obsidian Auto Sync:** ${state.preferences.obsidianAutoSync ? 'true' : 'false'}`);
    lines.push('');
  }

  // Tasks
  lines.push('## Tasks');
  lines.push('');
  if (state.tasks.length === 0) {
    lines.push('_No tasks yet._');
  } else {
    lines.push('| ID | Title | Description | Priority | Status | Due Date | Category | Energy | Quadrant | Created | Completed | Recurrence | RecurrenceParentId | RecurrenceNextDate | Subtasks |');
    lines.push('|----|-------|-------------|----------|--------|----------|----------|--------|----------|---------|-----------|------------|--------------------|--------------------|----------|');
    for (const t of state.tasks) {
      const subtasksJson = t.subtasks && t.subtasks.length > 0
        ? escapeField(JSON.stringify(t.subtasks))
        : '';
      lines.push(`| ${t.id} | ${escapeField(t.title)} | ${escapeField(t.description || '')} | ${t.priority} | ${t.status} | ${t.dueDate || ''} | ${t.category || ''} | ${t.energy || ''} | ${t.quadrant} | ${t.createdAt} | ${t.completedAt || ''} | ${t.recurrence || ''} | ${t.recurrenceParentId || ''} | ${t.recurrenceNextDate || ''} | ${subtasksJson} |`);
    }
  }
  lines.push('');

  // Pomodoros
  lines.push('## Pomodoros');
  lines.push('');
  if (state.pomodoros.length === 0) {
    lines.push('_No pomodoros yet._');
  } else {
    lines.push('| ID | Title | Duration | Elapsed | Status | Created | Completed | StartedAt | AccumulatedSeconds | LinkedTaskId |');
    lines.push('|----|-------|----------|---------|--------|---------|-----------|-----------|---------------------|--------------|');
    for (const p of state.pomodoros) {
      lines.push(`| ${p.id} | ${escapeField(p.title)} | ${p.duration} | ${p.elapsed} | ${p.status} | ${p.createdAt} | ${p.completedAt || ''} | ${p.startedAt || ''} | ${p.accumulatedSeconds ?? ''} | ${p.linkedTaskId || ''} |`);
    }
  }
  lines.push('');

  // Daily Stats
  lines.push('## Daily Stats');
  lines.push('');
  if (state.dailyStats.length === 0) {
    lines.push('_No stats yet._');
  } else {
    lines.push('| Date | Tasks Completed | Focus Minutes | Pomodoros Completed |');
    lines.push('|------|-----------------|---------------|---------------------|');
    for (const s of state.dailyStats) {
      lines.push(`| ${s.date} | ${s.tasksCompleted} | ${s.focusMinutes} | ${s.pomodorosCompleted} |`);
    }
  }
  lines.push('');

  // Templates
  if (state.templates && state.templates.length > 0) {
    lines.push('## Templates');
    lines.push('');
    lines.push('| ID | Name | Description | Tasks | Created |');
    lines.push('|----|------|-------------|-------|---------|');
    for (const tmpl of state.templates) {
      const tasksJson = escapeField(JSON.stringify(tmpl.tasks));
      lines.push(`| ${tmpl.id} | ${escapeField(tmpl.name)} | ${escapeField(tmpl.description || '')} | ${tasksJson} | ${tmpl.createdAt} |`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

function parseMarkdownTable(lines: string[]): string[][] {
  const rows: string[][] = [];
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed.startsWith('|')) continue;
    if (/^\|[\s\-:|]+\|$/.test(trimmed)) continue;
    // Split on unescaped pipes only (not preceded by backslash)
    const inner = trimmed.slice(1, -1); // remove leading/trailing |
    const cells: string[] = [];
    let current = '';
    for (let i = 0; i < inner.length; i++) {
      if (inner[i] === '\\' && i + 1 < inner.length && inner[i + 1] === '|') {
        current += '\\|';
        i++; // skip the pipe
      } else if (inner[i] === '|') {
        cells.push(unescapeField(current.trim()));
        current = '';
      } else {
        current += inner[i];
      }
    }
    cells.push(unescapeField(current.trim()));
    rows.push(cells);
  }
  return rows;
}

export function markdownToState(md: string): AppState {
  const state: AppState = {
    tasks: [],
    pomodoros: [],
    settings: { ...DEFAULT_SETTINGS },
    dailyStats: [],
    currentStreak: 0,
    templates: [],
    preferences: { ...DEFAULT_PREFERENCES },
  };

  const sections = md.split(/^## /m);

  for (const section of sections) {
    const sectionLines = section.split('\n');
    const title = sectionLines[0]?.trim().toLowerCase();

    if (title === 'settings') {
      for (const line of sectionLines) {
        const match = line.match(/\*\*(.+?):\*\*\s*(.+)/);
        if (!match) continue;
        const key = match[1].trim().toLowerCase();
        const val = match[2].trim();
        if (key === 'focus duration') state.settings.focusDuration = parseInt(val) || DEFAULT_SETTINGS.focusDuration;
        if (key === 'short break') state.settings.shortBreak = parseInt(val) || DEFAULT_SETTINGS.shortBreak;
        if (key === 'long break') state.settings.longBreak = parseInt(val) || DEFAULT_SETTINGS.longBreak;
        if (key === 'sessions before long break') state.settings.sessionsBeforeLongBreak = parseInt(val) || DEFAULT_SETTINGS.sessionsBeforeLongBreak;
        if (key === 'current streak') state.currentStreak = parseInt(val) || 0;
      }
    }

    if (title === 'preferences') {
      for (const line of sectionLines) {
        const match = line.match(/\*\*(.+?):\*\*\s*(.*)/);
        if (!match) continue;
        const key = match[1].trim().toLowerCase();
        const val = match[2].trim();
        if (key === 'notification sound') state.preferences!.notificationSound = (val as any) || 'gentle-chime';
        if (key === 'obsidian vault path') state.preferences!.obsidianVaultPath = val || '';
        if (key === 'obsidian auto sync') state.preferences!.obsidianAutoSync = val === 'true';
      }
    }

    if (title === 'tasks') {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        let subtasks = undefined;
        if (r[14]) {
          try { subtasks = JSON.parse(r[14]); } catch { /* ignore parse errors */ }
        }
        state.tasks.push({
          id: r[0],
          title: r[1] || '',
          description: r[2] || undefined,
          priority: (r[3] as Task['priority']) || 'medium',
          status: (r[4] as Task['status']) || 'active',
          dueDate: r[5] || undefined,
          category: (r[6] as Task['category']) || undefined,
          energy: (r[7] as Task['energy']) || undefined,
          quadrant: (r[8] as Task['quadrant']) || 'unassigned',
          createdAt: r[9] || new Date().toISOString(),
          completedAt: r[10] || undefined,
          recurrence: (r[11] as Task['recurrence']) || undefined,
          recurrenceParentId: r[12] || undefined,
          recurrenceNextDate: r[13] || undefined,
          subtasks,
        });
      }
    }

    if (title === 'pomodoros') {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        state.pomodoros.push({
          id: r[0],
          title: r[1] || '',
          duration: parseInt(r[2]) || 25,
          elapsed: parseInt(r[3]) || 0,
          status: (r[4] as Pomodoro['status']) || 'idle',
          createdAt: r[5] || new Date().toISOString(),
          completedAt: r[6] || undefined,
          startedAt: r[7] || undefined,
          accumulatedSeconds: r[8] ? parseInt(r[8]) : undefined,
          linkedTaskId: r[9] || undefined,
        });
      }
    }

    if (title === 'daily stats') {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        state.dailyStats.push({
          date: r[0],
          tasksCompleted: parseInt(r[1]) || 0,
          focusMinutes: parseInt(r[2]) || 0,
          pomodorosCompleted: parseInt(r[3]) || 0,
        });
      }
    }

    if (title === 'templates') {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        let tasks: TaskTemplate['tasks'] = [];
        if (r[3]) {
          try { tasks = JSON.parse(r[3]); } catch { /* ignore */ }
        }
        state.templates!.push({
          id: r[0],
          name: r[1] || '',
          description: r[2] || undefined,
          tasks,
          createdAt: r[4] || new Date().toISOString(),
        });
      }
    }
  }

  return state;
}

// ---- Public API ----

export async function loadFromMdFile(): Promise<AppState | null> {
  try {
    await ensureDataDir();
    const text = await fs.readFile(DATA_FILE, 'utf-8');
    if (!text.trim()) return null;
    return markdownToState(text);
  } catch (e: any) {
    if (e.code === 'ENOENT') return null;
    console.warn('Failed to read MD file:', e);
    return null;
  }
}

const MAX_BACKUPS = 5;

async function rotateBackups(): Promise<void> {
  try {
    // Check if main file exists
    await fs.access(DATA_FILE);
  } catch {
    return; // No file to backup
  }

  try {
    // Shift existing backups: .bak.5 → delete, .bak.4 → .bak.5, etc.
    for (let i = MAX_BACKUPS; i >= 1; i--) {
      const src = i === 1 ? DATA_FILE : `${DATA_FILE}.bak.${i - 1}`;
      const dst = `${DATA_FILE}.bak.${i}`;
      try {
        await fs.access(src);
        await fs.copyFile(src, dst);
      } catch {
        // Source doesn't exist, skip
      }
    }
  } catch (e) {
    console.warn('Backup rotation failed:', e);
  }
}

const DAILY_BACKUP_DIR = path.join(DATA_DIR, 'daily_backup');

/**
 * Create a daily snapshot if one doesn't exist yet for today.
 * Snapshots are stored as /data/daily_backup/YYYY-MM-DD.md and kept indefinitely.
 */
export async function createDailySnapshot(): Promise<void> {
  try {
    await fs.mkdir(DAILY_BACKUP_DIR, { recursive: true });
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    const snapshotPath = path.join(DAILY_BACKUP_DIR, `${today}.md`);
    try {
      await fs.access(snapshotPath);
      // Snapshot already exists for today, skip
      return;
    } catch {
      // Doesn't exist yet — create it
    }
    try {
      await fs.access(DATA_FILE);
      await fs.copyFile(DATA_FILE, snapshotPath);
    } catch {
      // No data file to snapshot yet
    }
  } catch (e) {
    console.warn('Daily snapshot failed:', e);
  }
}

export async function saveToMdFile(state: AppState): Promise<boolean> {
  try {
    await ensureDataDir();
    await rotateBackups();
    await createDailySnapshot();
    await fs.writeFile(DATA_FILE, stateToMarkdown(state), 'utf-8');
    return true;
  } catch (e) {
    console.warn('Failed to write MD file:', e);
    return false;
  }
}

/** Get the file's last modified timestamp for polling */
export async function getMdFileTimestamp(): Promise<number> {
  try {
    const stat = await fs.stat(DATA_FILE);
    return stat.mtimeMs;
  } catch {
    return 0;
  }
}

/** Data integrity check — verify and fix MD file structure */
export async function checkDataIntegrity(): Promise<{ ok: boolean; issues: string[]; fixed: string[] }> {
  const issues: string[] = [];
  const fixed: string[] = [];

  try {
    const text = await fs.readFile(DATA_FILE, 'utf-8');
    if (!text.trim()) {
      return { ok: true, issues: ['File is empty — no data to check'], fixed: [] };
    }

    const state = markdownToState(text);

    // Check for duplicate task IDs
    const taskIds = new Set<string>();
    for (const t of state.tasks) {
      if (taskIds.has(t.id)) {
        issues.push(`Duplicate task ID: ${t.id}`);
      }
      taskIds.add(t.id);
    }

    // Check for duplicate pomodoro IDs
    const pomIds = new Set<string>();
    for (const p of state.pomodoros) {
      if (pomIds.has(p.id)) {
        issues.push(`Duplicate pomodoro ID: ${p.id}`);
      }
      pomIds.add(p.id);
    }

    // Check for invalid task statuses
    for (const t of state.tasks) {
      if (!['active', 'done'].includes(t.status)) {
        issues.push(`Task "${t.title}" has invalid status: ${t.status}`);
        t.status = 'active';
        fixed.push(`Fixed task "${t.title}" status to "active"`);
      }
      if (!['low', 'medium', 'high', 'urgent'].includes(t.priority)) {
        issues.push(`Task "${t.title}" has invalid priority: ${t.priority}`);
        t.priority = 'medium';
        fixed.push(`Fixed task "${t.title}" priority to "medium"`);
      }
    }

    // Check for invalid pomodoro statuses
    for (const p of state.pomodoros) {
      if (!['idle', 'running', 'paused', 'completed'].includes(p.status)) {
        issues.push(`Pomodoro "${p.title}" has invalid status: ${p.status}`);
        p.status = 'idle';
        fixed.push(`Fixed pomodoro "${p.title}" status to "idle"`);
      }
    }

    // Check daily stats for duplicate dates
    const statDates = new Set<string>();
    const dedupedStats = [];
    for (const s of state.dailyStats) {
      if (statDates.has(s.date)) {
        issues.push(`Duplicate daily stats for date: ${s.date}`);
        fixed.push(`Removed duplicate stats for ${s.date}`);
      } else {
        statDates.add(s.date);
        dedupedStats.push(s);
      }
    }
    state.dailyStats = dedupedStats;

    // Check subtask integrity
    for (const t of state.tasks) {
      if (t.subtasks) {
        const subtaskIds = new Set<string>();
        for (const s of t.subtasks) {
          if (!s.id || !s.title) {
            issues.push(`Task "${t.title}" has malformed subtask`);
          }
          if (s.id && subtaskIds.has(s.id)) {
            issues.push(`Task "${t.title}" has duplicate subtask ID: ${s.id}`);
          }
          if (s.id) subtaskIds.add(s.id);
        }
      }
    }

    // If fixes were applied, re-save
    if (fixed.length > 0) {
      await saveToMdFile(state);
    }

    return {
      ok: issues.length === 0,
      issues: issues.length === 0 ? ['All data looks good!'] : issues,
      fixed,
    };
  } catch (e: any) {
    return {
      ok: false,
      issues: [`Failed to read data file: ${e.message}`],
      fixed: [],
    };
  }
}
