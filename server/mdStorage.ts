/**
 * Server-side Markdown file storage
 * 
 * Reads/writes app state to a local .md file on the server filesystem.
 * The file path defaults to ./data/focus-assist-data.md (Docker volume mount point).
 */
import fs from 'fs/promises';
import path from 'path';
import type { Task, Pomodoro, AppState } from '../shared/appTypes';
import { DEFAULT_SETTINGS } from '../shared/appTypes';

const DATA_DIR = process.env.DATA_DIR || path.join(process.cwd(), 'data');
const DATA_FILE = path.join(DATA_DIR, 'focus-assist-data.md');

async function ensureDataDir() {
  await fs.mkdir(DATA_DIR, { recursive: true });
}

// ---- Markdown serialization ----

function escapeField(val: string): string {
  return val.replace(/\|/g, '\\|').replace(/\n/g, '\\n');
}

function unescapeField(val: string): string {
  return val.replace(/\\n/g, '\n').replace(/\\\|/g, '|');
}

export function stateToMarkdown(state: AppState): string {
  const lines: string[] = [];

  lines.push('# Focus Assist Data');
  lines.push('');
  lines.push('> Auto-generated by Focus Assist. Edit with care.');
  lines.push('');

  // Settings
  lines.push('## Settings');
  lines.push('');
  lines.push(`- **Focus Duration:** ${state.settings.focusDuration} min`);
  lines.push(`- **Short Break:** ${state.settings.shortBreak} min`);
  lines.push(`- **Long Break:** ${state.settings.longBreak} min`);
  lines.push(`- **Sessions Before Long Break:** ${state.settings.sessionsBeforeLongBreak}`);
  lines.push(`- **Current Streak:** ${state.currentStreak} days`);
  lines.push('');

  // Tasks
  lines.push('## Tasks');
  lines.push('');
  if (state.tasks.length === 0) {
    lines.push('_No tasks yet._');
  } else {
    lines.push('| ID | Title | Description | Priority | Status | Due Date | Category | Energy | Quadrant | Created | Completed | Recurrence | RecurrenceParentId | RecurrenceNextDate |');
    lines.push('|----|-------|-------------|----------|--------|----------|----------|--------|----------|---------|-----------|------------|--------------------|--------------------|');
    for (const t of state.tasks) {
      lines.push(`| ${t.id} | ${escapeField(t.title)} | ${escapeField(t.description || '')} | ${t.priority} | ${t.status} | ${t.dueDate || ''} | ${t.category || ''} | ${t.energy || ''} | ${t.quadrant} | ${t.createdAt} | ${t.completedAt || ''} | ${t.recurrence || ''} | ${t.recurrenceParentId || ''} | ${t.recurrenceNextDate || ''} |`);
    }
  }
  lines.push('');

  // Pomodoros
  lines.push('## Pomodoros');
  lines.push('');
  if (state.pomodoros.length === 0) {
    lines.push('_No pomodoros yet._');
  } else {
    lines.push('| ID | Title | Duration | Elapsed | Status | Created | Completed | StartedAt | AccumulatedSeconds |');
    lines.push('|----|-------|----------|---------|--------|---------|-----------|-----------|---------------------|');
    for (const p of state.pomodoros) {
      lines.push(`| ${p.id} | ${escapeField(p.title)} | ${p.duration} | ${p.elapsed} | ${p.status} | ${p.createdAt} | ${p.completedAt || ''} | ${p.startedAt || ''} | ${p.accumulatedSeconds ?? ''} |`);
    }
  }
  lines.push('');

  // Daily Stats
  lines.push('## Daily Stats');
  lines.push('');
  if (state.dailyStats.length === 0) {
    lines.push('_No stats yet._');
  } else {
    lines.push('| Date | Tasks Completed | Focus Minutes | Pomodoros Completed |');
    lines.push('|------|-----------------|---------------|---------------------|');
    for (const s of state.dailyStats) {
      lines.push(`| ${s.date} | ${s.tasksCompleted} | ${s.focusMinutes} | ${s.pomodorosCompleted} |`);
    }
  }
  lines.push('');

  return lines.join('\n');
}

function parseMarkdownTable(lines: string[]): string[][] {
  const rows: string[][] = [];
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed.startsWith('|')) continue;
    if (/^\|[\s\-:|]+\|$/.test(trimmed)) continue;
    // Split on unescaped pipes only (not preceded by backslash)
    const inner = trimmed.slice(1, -1); // remove leading/trailing |
    const cells: string[] = [];
    let current = '';
    for (let i = 0; i < inner.length; i++) {
      if (inner[i] === '\\' && i + 1 < inner.length && inner[i + 1] === '|') {
        current += '\\|';
        i++; // skip the pipe
      } else if (inner[i] === '|') {
        cells.push(unescapeField(current.trim()));
        current = '';
      } else {
        current += inner[i];
      }
    }
    cells.push(unescapeField(current.trim()));
    rows.push(cells);
  }
  return rows;
}

export function markdownToState(md: string): AppState {
  const state: AppState = {
    tasks: [],
    pomodoros: [],
    settings: { ...DEFAULT_SETTINGS },
    dailyStats: [],
    currentStreak: 0,
  };

  const sections = md.split(/^## /m);

  for (const section of sections) {
    const sectionLines = section.split('\n');
    const title = sectionLines[0]?.trim().toLowerCase();

    if (title === 'settings') {
      for (const line of sectionLines) {
        const match = line.match(/\*\*(.+?):\*\*\s*(.+)/);
        if (!match) continue;
        const key = match[1].trim().toLowerCase();
        const val = match[2].trim();
        if (key === 'focus duration') state.settings.focusDuration = parseInt(val) || DEFAULT_SETTINGS.focusDuration;
        if (key === 'short break') state.settings.shortBreak = parseInt(val) || DEFAULT_SETTINGS.shortBreak;
        if (key === 'long break') state.settings.longBreak = parseInt(val) || DEFAULT_SETTINGS.longBreak;
        if (key === 'sessions before long break') state.settings.sessionsBeforeLongBreak = parseInt(val) || DEFAULT_SETTINGS.sessionsBeforeLongBreak;
        if (key === 'current streak') state.currentStreak = parseInt(val) || 0;
      }
    }

    if (title === 'tasks') {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        state.tasks.push({
          id: r[0],
          title: r[1] || '',
          description: r[2] || undefined,
          priority: (r[3] as Task['priority']) || 'medium',
          status: (r[4] as Task['status']) || 'active',
          dueDate: r[5] || undefined,
          category: (r[6] as Task['category']) || undefined,
          energy: (r[7] as Task['energy']) || undefined,
          quadrant: (r[8] as Task['quadrant']) || 'unassigned',
          createdAt: r[9] || new Date().toISOString(),
          completedAt: r[10] || undefined,
          recurrence: (r[11] as Task['recurrence']) || undefined,
          recurrenceParentId: r[12] || undefined,
          recurrenceNextDate: r[13] || undefined,
        });
      }
    }

    if (title === 'pomodoros') {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        state.pomodoros.push({
          id: r[0],
          title: r[1] || '',
          duration: parseInt(r[2]) || 25,
          elapsed: parseInt(r[3]) || 0,
          status: (r[4] as Pomodoro['status']) || 'idle',
          createdAt: r[5] || new Date().toISOString(),
          completedAt: r[6] || undefined,
          startedAt: r[7] || undefined,
          accumulatedSeconds: r[8] ? parseInt(r[8]) : undefined,
        });
      }
    }

    if (title === 'daily stats') {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        state.dailyStats.push({
          date: r[0],
          tasksCompleted: parseInt(r[1]) || 0,
          focusMinutes: parseInt(r[2]) || 0,
          pomodorosCompleted: parseInt(r[3]) || 0,
        });
      }
    }
  }

  return state;
}

// ---- Public API ----

export async function loadFromMdFile(): Promise<AppState | null> {
  try {
    await ensureDataDir();
    const text = await fs.readFile(DATA_FILE, 'utf-8');
    if (!text.trim()) return null;
    return markdownToState(text);
  } catch (e: any) {
    if (e.code === 'ENOENT') return null;
    console.warn('Failed to read MD file:', e);
    return null;
  }
}

const MAX_BACKUPS = 5;

async function rotateBackups(): Promise<void> {
  try {
    // Check if main file exists
    await fs.access(DATA_FILE);
  } catch {
    return; // No file to backup
  }

  try {
    // Shift existing backups: .bak.5 → delete, .bak.4 → .bak.5, etc.
    for (let i = MAX_BACKUPS; i >= 1; i--) {
      const src = i === 1 ? DATA_FILE : `${DATA_FILE}.bak.${i - 1}`;
      const dst = `${DATA_FILE}.bak.${i}`;
      try {
        await fs.access(src);
        await fs.copyFile(src, dst);
      } catch {
        // Source doesn't exist, skip
      }
    }
  } catch (e) {
    console.warn('Backup rotation failed:', e);
  }
}

export async function saveToMdFile(state: AppState): Promise<boolean> {
  try {
    await ensureDataDir();
    await rotateBackups();
    await fs.writeFile(DATA_FILE, stateToMarkdown(state), 'utf-8');
    return true;
  } catch (e) {
    console.warn('Failed to write MD file:', e);
    return false;
  }
}

/** Get the file's last modified timestamp for polling */
export async function getMdFileTimestamp(): Promise<number> {
  try {
    const stat = await fs.stat(DATA_FILE);
    return stat.mtimeMs;
  } catch {
    return 0;
  }
}
