/**
 * Local Markdown File Storage
 *
 * Uses the File System Access API to read/write app state to a local .md file.
 * The file is human-readable Markdown with YAML-like frontmatter sections.
 *
 * Browser support: Chrome 86+, Edge 86+, Opera 72+
 * Falls back gracefully â€” if unsupported, the app still works with localStorage.
 */

import type {
  Task,
  Pomodoro,
  TimerSettings,
  DailyStats,
  AppState,
} from "./types";
import { DEFAULT_SETTINGS } from "./types";

// ---- File handle persistence ----
let fileHandle: FileSystemFileHandle | null = null;

export function isFileSystemSupported(): boolean {
  return "showOpenFilePicker" in window;
}

export function hasFileHandle(): boolean {
  return fileHandle !== null;
}

/**
 * Prompt user to pick an existing .md file or create a new one.
 */
export async function pickFile(
  mode: "open" | "create" = "open"
): Promise<boolean> {
  try {
    if (mode === "create") {
      fileHandle = await (window as any).showSaveFilePicker({
        suggestedName: "focus-assist-data.md",
        types: [
          {
            description: "Markdown files",
            accept: { "text/markdown": [".md"] },
          },
        ],
      });
    } else {
      const [handle] = await (window as any).showOpenFilePicker({
        types: [
          {
            description: "Markdown files",
            accept: { "text/markdown": [".md"] },
          },
        ],
        multiple: false,
      });
      fileHandle = handle;
    }
    return true;
  } catch (e: any) {
    // User cancelled the picker
    if (e.name === "AbortError") return false;
    console.warn("File picker failed:", e);
    return false;
  }
}

export function disconnectFile(): void {
  fileHandle = null;
}

// ---- Markdown serialization ----

function escapeField(val: string): string {
  return val.replace(/\|/g, "\\|").replace(/\n/g, "\\n");
}

function unescapeField(val: string): string {
  return val.replace(/\\n/g, "\n").replace(/\\\|/g, "|");
}

function stateToMarkdown(state: AppState): string {
  const lines: string[] = [];

  lines.push("# Focus Assist Data");
  lines.push("");
  lines.push("> Auto-generated by Focus Assist. Edit with care.");
  lines.push("");

  // Settings
  lines.push("## Settings");
  lines.push("");
  lines.push(`- **Focus Duration:** ${state.settings.focusDuration} min`);
  lines.push(`- **Short Break:** ${state.settings.shortBreak} min`);
  lines.push(`- **Long Break:** ${state.settings.longBreak} min`);
  lines.push(
    `- **Sessions Before Long Break:** ${state.settings.sessionsBeforeLongBreak}`
  );
  lines.push(`- **Current Streak:** ${state.currentStreak} days`);
  lines.push("");

  // Tasks
  lines.push("## Tasks");
  lines.push("");
  if (state.tasks.length === 0) {
    lines.push("_No tasks yet._");
  } else {
    lines.push(
      "| ID | Title | Description | Priority | Status | Due Date | Category | Energy | Quadrant | Created | Completed |"
    );
    lines.push(
      "|----|-------|-------------|----------|--------|----------|----------|--------|----------|---------|-----------|"
    );
    for (const t of state.tasks) {
      lines.push(
        `| ${t.id} | ${escapeField(t.title)} | ${escapeField(t.description || "")} | ${t.priority} | ${t.status} | ${t.dueDate || ""} | ${t.category || ""} | ${t.energy || ""} | ${t.quadrant} | ${t.createdAt} | ${t.completedAt || ""} |`
      );
    }
  }
  lines.push("");

  // Pomodoros
  lines.push("## Pomodoros");
  lines.push("");
  if (state.pomodoros.length === 0) {
    lines.push("_No pomodoros yet._");
  } else {
    lines.push(
      "| ID | Title | Duration | Elapsed | Status | Created | Completed |"
    );
    lines.push(
      "|----|-------|----------|---------|--------|---------|-----------|"
    );
    for (const p of state.pomodoros) {
      lines.push(
        `| ${p.id} | ${escapeField(p.title)} | ${p.duration} | ${p.elapsed} | ${p.status} | ${p.createdAt} | ${p.completedAt || ""} |`
      );
    }
  }
  lines.push("");

  // Daily Stats
  lines.push("## Daily Stats");
  lines.push("");
  if (state.dailyStats.length === 0) {
    lines.push("_No stats yet._");
  } else {
    lines.push(
      "| Date | Tasks Completed | Focus Minutes | Pomodoros Completed |"
    );
    lines.push(
      "|------|-----------------|---------------|---------------------|"
    );
    for (const s of state.dailyStats) {
      lines.push(
        `| ${s.date} | ${s.tasksCompleted} | ${s.focusMinutes} | ${s.pomodorosCompleted} |`
      );
    }
  }
  lines.push("");

  return lines.join("\n");
}

function parseMarkdownTable(lines: string[]): string[][] {
  // Find table rows (lines starting with |), skip separator row (|---|)
  const rows: string[][] = [];
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed.startsWith("|")) continue;
    // Skip separator rows
    if (/^\|[\s\-:|]+\|$/.test(trimmed)) continue;
    const cells = trimmed
      .split("|")
      .slice(1, -1) // remove empty first/last from split
      .map(c => unescapeField(c.trim()));
    rows.push(cells);
  }
  return rows;
}

function markdownToState(md: string): AppState {
  const state: AppState = {
    tasks: [],
    pomodoros: [],
    settings: { ...DEFAULT_SETTINGS },
    dailyStats: [],
    currentStreak: 0,
  };

  const sections = md.split(/^## /m);

  for (const section of sections) {
    const sectionLines = section.split("\n");
    const title = sectionLines[0]?.trim().toLowerCase();

    if (title === "settings") {
      for (const line of sectionLines) {
        const match = line.match(/\*\*(.+?):\*\*\s*(.+)/);
        if (!match) continue;
        const key = match[1].trim().toLowerCase();
        const val = match[2].trim();
        if (key === "focus duration")
          state.settings.focusDuration =
            parseInt(val) || DEFAULT_SETTINGS.focusDuration;
        if (key === "short break")
          state.settings.shortBreak =
            parseInt(val) || DEFAULT_SETTINGS.shortBreak;
        if (key === "long break")
          state.settings.longBreak =
            parseInt(val) || DEFAULT_SETTINGS.longBreak;
        if (key === "sessions before long break")
          state.settings.sessionsBeforeLongBreak =
            parseInt(val) || DEFAULT_SETTINGS.sessionsBeforeLongBreak;
        if (key === "current streak") state.currentStreak = parseInt(val) || 0;
      }
    }

    if (title === "tasks") {
      const rows = parseMarkdownTable(sectionLines);
      // Skip header row
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        state.tasks.push({
          id: r[0],
          title: r[1] || "",
          description: r[2] || undefined,
          priority: (r[3] as Task["priority"]) || "medium",
          status: (r[4] as Task["status"]) || "active",
          dueDate: r[5] || undefined,
          category: (r[6] as Task["category"]) || undefined,
          energy: (r[7] as Task["energy"]) || undefined,
          quadrant: (r[8] as Task["quadrant"]) || "unassigned",
          createdAt: r[9] || new Date().toISOString(),
          completedAt: r[10] || undefined,
        });
      }
    }

    if (title === "pomodoros") {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        state.pomodoros.push({
          id: r[0],
          title: r[1] || "",
          duration: parseInt(r[2]) || 25,
          elapsed: parseInt(r[3]) || 0,
          status: (r[4] as Pomodoro["status"]) || "idle",
          createdAt: r[5] || new Date().toISOString(),
          completedAt: r[6] || undefined,
        });
      }
    }

    if (title === "daily stats") {
      const rows = parseMarkdownTable(sectionLines);
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r[0]) continue;
        state.dailyStats.push({
          date: r[0],
          tasksCompleted: parseInt(r[1]) || 0,
          focusMinutes: parseInt(r[2]) || 0,
          pomodorosCompleted: parseInt(r[3]) || 0,
        });
      }
    }
  }

  return state;
}

// ---- Public API ----

export async function loadFromFile(): Promise<AppState | null> {
  if (!fileHandle) return null;
  try {
    const file = await fileHandle.getFile();
    const text = await file.text();
    if (!text.trim()) return null;
    return markdownToState(text);
  } catch (e) {
    console.warn("Failed to read MD file:", e);
    return null;
  }
}

export async function saveToFile(state: AppState): Promise<boolean> {
  if (!fileHandle) return false;
  try {
    const writable = await (fileHandle as any).createWritable();
    await writable.write(stateToMarkdown(state));
    await writable.close();
    return true;
  } catch (e) {
    console.warn("Failed to write MD file:", e);
    return false;
  }
}

export function getFileName(): string | null {
  return fileHandle?.name || null;
}
